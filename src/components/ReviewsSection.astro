---
import { Icon } from '@astrojs/starlight/components';

const {
  owner = 'meowrch',
  repo = 'meowrch',
  category = 'Reviews',
  heading = '',
  locale = 'auto',
} = Astro.props;

const resolvedLocale = locale === 'ru' ? 'ru' : (locale === 'en' ? 'en' : 'en');
const serverTexts = {
  en: { heading: 'Reviews', leave: 'Leave a review' },
  ru: { heading: 'Отзывы', leave: 'Оставить отзыв' },
};
const fallbackHeading = heading || serverTexts[resolvedLocale].heading;
---
<section class="reviews-section" data-owner={owner} data-repo={repo} data-category={category} data-locale={locale}>
  <div class="section-header">
    
    <h2 class="section-title">
      <Icon name="star" class="icon" style="width: 2.5rem; height: 2.5rem;" />
      <span class="title-text">{fallbackHeading}</span>
    </h2>
    <div class="avg-chip" aria-live="polite">
      <span class="avg-stars" aria-hidden="true"></span>
      <span class="avg-number">–</span>
      <span class="avg-count text-muted"></span>
    </div>
  </div>

  <div class="grid" data-grid>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
  </div>

<div class="actions">
  <button type="button" class="btn-primary" data-open-modal>
    <span class="btn-text">{serverTexts[resolvedLocale].leave}</span>
  </button>
</div>

  <div class="reviews-nav" hidden data-nav>
    <button type="button" class="nav-btn" data-prev aria-label="Previous">‹</button>
    <span class="nav-page" data-page>1 / 1</span>
    <button type="button" class="nav-btn" data-next aria-label="Next">›</button>
  </div>

  <!-- Modal: Leave a review -->
  <div class="modal-mask" hidden data-modal>
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      <div class="modal-header">
        <h3 id="modal-title">
          <span class="icon" aria-hidden="true">★</span>
          <span class="modal-title-text"></span>
        </h3>
        <button type="button" class="modal-close" data-close-modal aria-label="Close">✕</button>
      </div>
      <div class="modal-body">
        <div class="stars-select" data-stars>
          <label data-stars-label></label>
          <div class="stars-row" role="radiogroup" aria-label="Rating">
            <button type="button" class="star-btn" data-value="1" aria-label="1 star">☆</button>
            <button type="button" class="star-btn" data-value="2" aria-label="2 stars">☆</button>
            <button type="button" class="star-btn" data-value="3" aria-label="3 stars">☆</button>
            <button type="button" class="star-btn" data-value="4" aria-label="4 stars">☆</button>
            <button type="button" class="star-btn" data-value="5" aria-label="5 stars">☆</button>
          </div>
        </div>
        <textarea class="review-text" rows="5" data-text placeholder=""></textarea>
        <div class="modal-actions">
          <a class="btn-primary" target="_blank" rel="noopener noreferrer" data-submit disabled></a>
        </div>
        <div class="hint" data-hint></div>
      </div>
    </div>
  </div>

  <!-- Modal: View full review -->
  <div class="modal-mask" hidden data-view-modal>
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="view-modal-title">
      <div class="modal-header">
        <h3 id="view-modal-title">
          <span class="icon" aria-hidden="true">★</span>
          <span class="view-title-text"></span>
        </h3>
        <button type="button" class="modal-close" data-close-view aria-label="Close">✕</button>
      </div>
      <div class="modal-body">
        <div class="modal-review-header">
          <div class="view-author">
            <img class="avatar" data-v-avatar alt="" />
            <a class="username" target="_blank" rel="noopener noreferrer" data-v-link></a>
          </div>
          <div class="view-rating">
            <span class="stars" data-v-stars></span>
            <time class="date" data-v-date></time>
          </div>
        </div>
        <blockquote class="text" data-v-text></blockquote>
      </div>
    </div>
  </div>

  <div class="sr-only" aria-live="polite" data-status></div>
  <noscript>
    <div class="empty">Enable JavaScript to load reviews from GitHub Discussions.</div>
  </noscript>
</section>

<script is:inline>
(() => {
  // Guard against double initialization on pages with multiple renders
  const INIT_ATTR = 'data-reviews-init';

  // Shared helpers (scoped to this IIFE, so no global redeclarations)
  const CACHE_PREFIX = 'reviews_';
  const CACHE_DURATION = 60 * 60 * 1000; // 60 minutes cache to reduce API calls
  const MIN_FETCH_INTERVAL = 10 * 60 * 1000; // at most one network refresh per 10 minutes
  const qs = (root, sel) => root.querySelector(sel);

  const i18nDict = {
    en: {
      heading: 'Reviews',
      loading: 'Loading reviews…',
      empty: 'No reviews yet',
      error: 'Failed to load reviews',
      rateLimit: 'GitHub API rate limit reached. Please try again later.',
      count: (n) => `· ${n}`,
      leave: 'Leave a review',
      modalTitle: 'Leave a review',
      viewTitle: 'Review',
      yourRating: 'Your rating',
      placeholder: 'Write your review here…',
      submit: 'Open GitHub to submit',
      date: (d) => new Date(d).toLocaleDateString('en', { year: 'numeric', month: 'short', day: 'numeric' })
    },
    ru: {
      heading: 'Отзывы',
      loading: 'Загрузка отзывов…',
      empty: 'Пока нет отзывов',
      error: 'Не удалось загрузить отзывы',
      rateLimit: 'Превышен лимит GitHub API. Попробуйте позже.',
      count: (n) => `· ${n}`,
      leave: 'Оставить отзыв',
      modalTitle: 'Оставить отзыв',
      viewTitle: 'Отзыв',
      yourRating: 'Ваш рейтинг',
      placeholder: 'Напишите ваш отзыв здесь…',
      submit: 'Открыть GitHub для отправки',
      date: (d) => new Date(d).toLocaleDateString('ru', { year: 'numeric', month: 'short', day: 'numeric' })
    }
  };

  let RATE_LIMITED = false;

  function isCacheDisabled() {
    try {
      const params = new URLSearchParams(window.location.search);
      if (params.get('noReviewsCache') === '1') return true;
      if (localStorage.getItem('reviews_disable_cache') === '1') return true;
    } catch (_) {}
    return false;
  }
  function parseReviewBody(body) {
    const review = { rating: 0, text: '', author_info: '' };
    const firstLine = (body || '').split('\n')[0] || '';
    const starMatches = firstLine.match(/(?:⭐️|⭐|★)/g);
    if (starMatches && starMatches.length) {
      review.rating = starMatches.length;
    } else {
      const ratingMatch = body.match(/Rating:\s*(\d+)/);
      if (ratingMatch) review.rating = parseInt(ratingMatch[1]);
    }
    review.rating = Math.max(0, Math.min(5, review.rating || 0));
    let textContent = body
      .replace(/^(?:\s*)(?:⭐️|⭐|★)+\s*/m, '')
      .replace(/Rating:\s*\d+/, '');
    const authorMatch = textContent.match(/Author:\s*(.+?)(?:\n|$)/m);
    if (authorMatch) {
      review.author_info = authorMatch[1].trim();
      textContent = textContent.replace(/Author:\s*.+?(?:\n|$)/m, '');
    }
    review.text = textContent.trim();
    return review;
  }
  async function getReviewsFromDiscussions(owner, repo) {
    try {
      const resp = await fetch(`https://api.github.com/repos/${owner}/${repo}/discussions?per_page=20`, {
        headers: { 'Accept': 'application/vnd.github+json', 'X-GitHub-Api-Version': '2022-11-28' }
      });
      if (resp.status === 403) { RATE_LIMITED = true; return []; }
      if (!resp.ok) return [];
      const discussions = await resp.json();
      return discussions.map(d => {
        const parsed = parseReviewBody(d.body || '');
        const user = d.user || d.author || {};
        return {
          id: `d_${String(d.id)}`,
          title: d.title,
          rating: parsed.rating,
          text: parsed.text,
          author: {
            name: parsed.author_info || user.login || 'Anonymous',
            username: user.login,
            avatar: user.avatar_url || user.avatarUrl,
            url: user.html_url || user.url
          },
          createdAt: d.created_at || d.createdAt,
          updatedAt: d.updated_at || d.updatedAt,
          upvotes: (d.reactions && d.reactions['+1']) || d.upvoteCount || 0,
          commentsCount: d.comments || (d.comments_count ?? 0)
        };
      }).filter(r => r.rating > 0);
    } catch (e) {
      console.error('Discussions fetch failed:', e);
      return [];
    }
  }
  async function getReviewsFromIssues(owner, repo) {
    try {
      const resp = await fetch(`https://api.github.com/repos/${owner}/${repo}/issues?labels=review&state=all&per_page=20`, {
        headers: { 'Accept': 'application/vnd.github+json', 'X-GitHub-Api-Version': '2022-11-28' }
      });
      if (resp.status === 403) { RATE_LIMITED = true; return []; }
      if (!resp.ok) return [];
      const issues = await resp.json();
      return issues.map(issue => {
        const parsed = parseReviewBody(issue.body || '');
        return {
          id: String(issue.id),
          title: issue.title,
          rating: parsed.rating,
          text: parsed.text,
          author: {
            name: parsed.author_info || issue.user?.login || 'Anonymous',
            username: issue.user?.login,
            avatar: issue.user?.avatar_url,
            url: issue.user?.html_url
          },
          createdAt: issue.created_at,
          updatedAt: issue.updated_at,
          upvotes: issue.reactions?.['+1'] || 0,
          commentsCount: issue.comments || 0
        };
      }).filter(r => r.rating > 0);
    } catch (e) {
      console.error('Issues fallback failed:', e);
      return [];
    }
  }
  function getCachedData(key) {
    try {
      const cached = localStorage.getItem(key);
      if (!cached) return null;
      const { data, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp > CACHE_DURATION) {
        localStorage.removeItem(key);
        return null;
      }
      return data;
    } catch (e) {
      console.error('Cache read failed:', e);
      return null;
    }
  }
  function setCachedData(key, data) {
    try {
      localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
    } catch (e) {
      console.error('Cache write failed:', e);
    }
  }
  function getLastFetchTS(key) {
    try { const v = localStorage.getItem('lf_' + key); return v ? parseInt(v) : 0; } catch { return 0; }
  }
  function setLastFetchTS(key) {
    try { localStorage.setItem('lf_' + key, String(Date.now())); } catch {}
  }
  async function getReviews(owner, repo, category = 'Reviews') {
    const cacheKey = `${CACHE_PREFIX}${owner}_${repo}_${category}`;
    const cached = isCacheDisabled() ? null : getCachedData(cacheKey);
    const lastTs = getLastFetchTS(cacheKey);
    // If we have cache and we fetched recently, serve cache and skip network
    if (cached && (Date.now() - lastTs) < MIN_FETCH_INTERVAL) return cached;

    const [a, b] = await Promise.all([
      getReviewsFromDiscussions(owner, repo),
      getReviewsFromIssues(owner, repo)
    ]);
    const all = [...a, ...b].sort((x, y) => new Date(y.createdAt) - new Date(x.createdAt));

    if (!isCacheDisabled() && all.length) {
      setCachedData(cacheKey, all);
      setLastFetchTS(cacheKey);
    } else if (cached) {
      // No new data (or request failed), return cached to avoid empty UI
      return cached;
    }
    return all;
  }
  function calculateAverageRating(reviews) {
    if (!reviews || !reviews.length) return 0;
    const sum = reviews.reduce((acc, r) => acc + Math.max(0, Math.min(5, r.rating || 0)), 0);
    return Math.round((sum / reviews.length) * 10) / 10;
  }
  function renderStars(value, size = 18) {
    const v = Math.max(0, Math.min(5, Math.round(value)));
    const full = '★'.repeat(v);
    const empty = '☆'.repeat(5 - v);
    return `<span class="stars" style="font-size:${size}px" aria-label="${v} / 5">${full}<span class="empty">${empty}</span></span>`;
  }
  function escapeHtml(str = '') {
    return String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');
  }

  function initSection(root) {
    if (!root || root.hasAttribute(INIT_ATTR)) return;
    root.setAttribute(INIT_ATTR, '1');

    const grid = qs(root, '[data-grid]');
    const status = qs(root, '[data-status]');
    const avgStars = qs(root, '.avg-stars');
    const avgNumber = qs(root, '.avg-number');
    const avgCount = qs(root, '.avg-count');
    const titleText = qs(root, '.title-text');

    const nav = qs(root, '[data-nav]');
    const prevBtn = qs(root, '[data-prev]');
    const nextBtn = qs(root, '[data-next]');
    const pageEl = qs(root, '[data-page]');

    const btnOpenModal = qs(root, '[data-open-modal]');
    const modal = qs(root, '[data-modal]');
    const btnCloseModal = qs(root, '[data-close-modal]');
    const viewModal = qs(root, '[data-view-modal]');
    const btnCloseView = viewModal ? viewModal.querySelector('[data-close-view]') : null;
    const starsLabel = qs(root, '[data-stars-label]');
    const starsRow = qs(root, '.stars-row');
    const textarea = qs(root, '[data-text]');
    const btnSubmit = qs(root, '[data-submit]');

    const vAvatar = qs(root, '[data-v-avatar]');
    const vLink = qs(root, '[data-v-link]');
    const vStars = qs(root, '[data-v-stars]');
    const vDate = qs(root, '[data-v-date]');
    const vText = qs(root, '[data-v-text]');
    const viewTitle = qs(root, '.view-title-text');

    const owner = root.dataset.owner || 'meowrch';
    const repo = root.dataset.repo || 'meowrch';
    const category = root.dataset.category || 'Reviews';
    const detectedLocale = (root.dataset.locale === 'auto'
      ? (document.documentElement.lang || 'en').toLowerCase().split('-')[0]
      : root.dataset.locale || 'en');
    const L = detectedLocale.startsWith('ru') ? 'ru' : 'en';
    const i18n = i18nDict[L];

    // Texts
    titleText.textContent = (root.getAttribute('data-heading') || '') || i18n.heading;
    status.textContent = i18n.loading;
    btnOpenModal.querySelector('.btn-text').textContent = i18n.leave;
    qs(root, '.modal-title-text').textContent = i18n.modalTitle;
    starsLabel.textContent = i18n.yourRating;
    textarea.placeholder = i18n.placeholder;
    btnSubmit.textContent = i18n.submit;

    // --- Paging state
    let allReviews = [];
    let currentPage = 1;
    let perPage = computePerPage();
    function computePerPage() {
      return window.matchMedia('(max-width: 640px)').matches ? 1 : 6;
    }
    function totalPages() {
      return Math.max(1, Math.ceil((allReviews?.length || 0) / perPage));
    }
    function renderPage() {
      if (!Array.isArray(allReviews) || allReviews.length === 0) {
        // handled earlier (empty/rateLimit)
        if (nav) nav.hidden = true;
        return;
      }
      const tp = totalPages();
      const start = (currentPage - 1) * perPage;
      const end = start + perPage;
      const pageItems = allReviews.slice(start, end);

      grid.innerHTML = pageItems.map((r) => {
        const avatar = r?.author?.avatar ? `<img class=\"avatar\" src=\"${r.author.avatar}\" alt=\"\" loading=\"lazy\" />` : '';
        const username = r?.author?.username || r?.author?.name || 'User';
        const userLinkOpen = r?.author?.url ? `<a class=\"username\" href=\"${r.author.url}\" target=\"_blank\" rel=\"noopener noreferrer\">` : `<span class=\"username\">`;
        const userLinkClose = r?.author?.url ? `</a>` : `</span>`;
        const date = (r?.createdAt ? i18n.date(r.createdAt) : '');
        return `
          <article class=\"card\" tabindex=\"0\" data-rating=\"${r.rating}\" data-created=\"${r.createdAt}\">
            <header class=\"card-header\">${avatar}<div class=\"meta\">${userLinkOpen}${username}${userLinkClose}</div></header>
            <blockquote class=\"text\">${escapeHtml(r.text)}</blockquote>
            <div class=\"full-text\" style=\"display:none\">${escapeHtml(r.text)}</div>
            <footer class=\"card-footer\"><div class=\"rating\">${renderStars(r.rating, 20)}</div><time class=\"date\">${date}</time></footer>
          </article>`;
      }).join('');

      if (nav && prevBtn && nextBtn && pageEl) {
        nav.hidden = tp <= 1;
        pageEl.textContent = `${currentPage} / ${tp}`;
        prevBtn.disabled = currentPage <= 1;
        nextBtn.disabled = currentPage >= tp;
      }
    }

    if (prevBtn) prevBtn.addEventListener('click', () => {
      if (currentPage > 1) { currentPage--; renderPage(); }
    });
    if (nextBtn) nextBtn.addEventListener('click', () => {
      if (currentPage < totalPages()) { currentPage++; renderPage(); }
    });
    window.addEventListener('resize', () => {
      const newPer = computePerPage();
      if (newPer !== perPage) {
        perPage = newPer;
        if (currentPage > totalPages()) currentPage = totalPages();
        renderPage();
      }
    });

    // --- Modal state
    let draftRating = 0;
    let draftText = '';
    function updateStarsUI() {
      const btns = starsRow.querySelectorAll('.star-btn');
      btns.forEach(btn => {
        const v = Number(btn.dataset.value || '0');
        btn.textContent = v <= draftRating ? '★' : '☆';
        btn.setAttribute('aria-pressed', String(v <= draftRating));
      });
      updateSubmitState();
    }
    function updateSubmitState() {
      const ok = draftRating > 0 && draftText.trim().length > 0;
      btnSubmit.toggleAttribute('disabled', !ok);
      const url = new URL(`https://github.com/${owner}/${repo}/discussions/new`);
      if (category) url.searchParams.set('category', category);
      const stars = '⭐'.repeat(draftRating);
      const bodyLines = [stars, '', draftText.trim()];
      url.searchParams.set('title', L === 'ru' ? `Отзыв (${draftRating}/5)` : `Review (${draftRating}/5)`);
      url.searchParams.set('body', bodyLines.join('\n'));
      btnSubmit.href = url.toString();
    }
    btnOpenModal.addEventListener('click', () => {
      modal.hidden = false;
      document.body.style.overflow = 'hidden';
    });
    btnCloseModal.addEventListener('click', () => {
      modal.hidden = true;
      document.body.style.overflow = '';
    });
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.hidden = true;
        document.body.style.overflow = '';
      }
    });

    // View modal handlers
    if (btnCloseView) {
      btnCloseView.addEventListener('click', () => {
        viewModal.hidden = true;
        document.body.style.overflow = '';
      });
    }
    if (viewModal) {
      viewModal.addEventListener('click', (e) => {
        if (e.target === viewModal) {
          viewModal.hidden = true;
          document.body.style.overflow = '';
        }
      });
    }
    starsRow.addEventListener('click', (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const val = Number(t.dataset.value || '0');
      if (val >= 1 && val <= 5) {
        draftRating = val;
        updateStarsUI();
      }
    });
    textarea.addEventListener('input', () => {
      draftText = textarea.value;
      updateSubmitState();
    });

    // Open view modal on card click (event delegation)
    grid.addEventListener('click', (e) => {
      const t = e.target;
      if (!(t instanceof Element)) return;
      const card = t.closest('.card');
      if (!card || !viewModal) return;
      const avatarEl = card.querySelector('.avatar');
      const nameEl = card.querySelector('.username');
      const rating = Number(card.getAttribute('data-rating') || '0');
      const created = card.getAttribute('data-created') || '';
      const fullTextEl = card.querySelector('.full-text');

      // Fill modal
      if (viewTitle) viewTitle.textContent = i18n.viewTitle;
      if (vAvatar) vAvatar.src = avatarEl ? (avatarEl.getAttribute('src') || '') : '';
      if (vLink) {
        const text = nameEl ? nameEl.textContent : 'User';
        vLink.textContent = text || '';
        if (nameEl && nameEl.tagName === 'A') {
          const href = nameEl.getAttribute('href');
          if (href) vLink.href = href; else vLink.removeAttribute('href');
        } else {
          vLink.removeAttribute('href');
        }
      }
      if (vStars) vStars.innerHTML = renderStars(rating, 22);
      if (vDate) vDate.textContent = created ? i18n.date(created) : '';
      if (vText) vText.textContent = fullTextEl ? fullTextEl.textContent : '';

      // Show
      viewModal.hidden = false;
      document.body.style.overflow = 'hidden';
    });

    // Load reviews
    (async () => {
      try {
        const reviews = await getReviews(owner, repo, category);
        if (!Array.isArray(reviews) || reviews.length === 0) {
          const msg = RATE_LIMITED ? i18n.rateLimit : i18n.empty;
          const cls = RATE_LIMITED ? 'error' : 'empty';
          grid.innerHTML = `<div class=\"empty-grid\"><div class=\"${cls}\">${msg}</div></div>`;
          avgStars.innerHTML = renderStars(0, 18);
          avgNumber.textContent = RATE_LIMITED ? '–' : '0.0';
          avgCount.textContent = RATE_LIMITED ? '' : i18n.count(0);
          status.textContent = msg;
          return;
        }
        const avg = calculateAverageRating(reviews);
        avgStars.innerHTML = renderStars(avg, 18);
        avgNumber.textContent = avg.toFixed(1);
        avgCount.textContent = i18n.count(reviews.length);

        allReviews = reviews;
        currentPage = 1;
        perPage = computePerPage();
        renderPage();
        status.textContent = '';
        updateStarsUI();
      } catch (e) {
        console.error(e);
        grid.innerHTML = `<div class=\"empty-grid\"><div class=\"error\">${i18n.error}</div></div>`;
        avgStars.innerHTML = renderStars(0, 18);
        avgNumber.textContent = '–';
        avgCount.textContent = '';
        status.textContent = i18n.error;
      }
    })();
  }

  function initAll() {
    document.querySelectorAll('.reviews-section').forEach(initSection);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAll, { once: true });
  } else {
    initAll();
  }
  // Re-init after Astro view transitions if enabled
  document.addEventListener('astro:page-load', initAll);
})();
</script>

<style is:global>
.reviews-section { margin: 3rem 0; }
.reviews-section .section-header { display: flex; align-items: center; justify-content: space-between; gap: 1rem; margin-bottom: 1rem; }
.reviews-section .section-title { display: flex; align-items: center; gap: .6rem; margin: 0; color: var(--ctp-text); font-size: 3rem; font-weight: 900; }
.reviews-section .section-title .icon { color: var(--ctp-text); }

.reviews-section .avg-chip { display: inline-flex; align-items: center; gap: .5rem; background: var(--ctp-surface0); color: var(--ctp-text); border: 1px solid var(--ctp-surface1); padding: .5rem .75rem; border-radius: .75rem; font-weight: 700; }
.reviews-section .avg-chip .stars { color: #f5b301; }
.reviews-section .avg-chip .stars .empty { color: color-mix(in oklab, #f5b301 30%, transparent); }
.reviews-section .avg-number { min-width: 2.5ch; text-align: right; }
.reviews-section .text-muted { opacity: .8; }

.reviews-section .grid { display: grid; grid-template-columns: repeat(1, minmax(0, 1fr)); gap: 1rem; }
@media (min-width: 640px) { .reviews-section .grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
@media (min-width: 1024px) { .reviews-section .grid { grid-template-columns: repeat(3, minmax(0, 1fr)); } }

/* Review cards - both static and dynamic */
.reviews-section .card, .reviews-section .skeleton-card {
  background: var(--ctp-surface0, #313244);
  border: 1px solid var(--ctp-surface1, #45475a);
  color: var(--ctp-text, #cdd6f4);
  border-radius: 1rem;
  padding: 1rem;
  min-height: 240px;
  display: flex;
  flex-direction: column;
  gap: .75rem;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  margin: 0;
}
.reviews-section .card:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.15); border-color: var(--ctp-mauve, #cba6f7); }
.reviews-section .card:focus { outline: 2px solid var(--ctp-mauve, #cba6f7); outline-offset: 2px; }

.reviews-section .skeleton-card { position: relative; overflow: hidden; }
.reviews-section .skeleton-card::after { content: ''; position: absolute; inset: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,.06), transparent); animation: shimmer 1.5s infinite; }
@keyframes shimmer { from { transform: translateX(-100%); } to { transform: translateX(100%); } }

/* Card content styles */
.reviews-section .card-header { display: flex; align-items: center; gap: .75rem; }
.reviews-section .avatar { width: 56px; height: 56px; border-radius: 50%; border: 2px solid var(--ctp-mauve, #cba6f7); object-fit: cover; flex-shrink: 0; }
.reviews-section .username { color: var(--ctp-text, #cdd6f4); font-weight: 800; text-decoration: none; font-size: 1.25rem; line-height: 1.25; display: inline-block; }
.reviews-section .username:hover { text-decoration: underline; color: var(--ctp-mauve, #cba6f7); }
.reviews-section .meta { display: flex; align-items: center; gap: .25rem; flex: 1; min-width: 0; }

.reviews-section .text { margin: .25rem 0 .5rem 0; color: var(--ctp-subtext1, #bac2de); line-height: 1.6; white-space: pre-wrap; display: -webkit-box; -webkit-line-clamp: 5; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; flex: 1; }

.reviews-section .card-footer { display: flex; align-items: center; justify-content: space-between; gap: .5rem; margin-top: auto; }
.reviews-section .card-footer .rating .stars { font-size: 20px; color: #f5b301; }
.reviews-section .card-footer .rating .stars .empty { color: rgba(245, 179, 1, 0.3); }
.reviews-section .card-footer .date { opacity: .8; font-size: .95rem; white-space: nowrap; color: var(--ctp-subtext0, #a6adc8); }

.reviews-section .reviews-nav { display: flex; align-items: center; justify-content: center; gap: 12px; margin: 12px 0; }
.reviews-section .reviews-nav .nav-btn { border: 1px solid var(--ctp-surface1); background: var(--ctp-surface0); color: var(--ctp-text); border-radius: 8px; padding: 6px 10px; cursor: pointer; }
.reviews-section .reviews-nav .nav-btn:disabled { opacity: .5; cursor: default; }
.reviews-section .reviews-nav .nav-page { min-width: 80px; text-align: center; color: var(--ctp-subtext1); }

.reviews-section .actions { margin: 1rem 0 .5rem; display: flex; justify-content: center; }
.reviews-section .btn-primary { display: inline-flex; align-items: center; justify-content: center; gap: .5rem; padding: 1rem 1.75rem; border-radius: .85rem; text-decoration: none; background: linear-gradient(135deg, var(--ctp-mauve), var(--ctp-lavender)); color: var(--ctp-crust); font-weight: 800; border: none; min-width: 350px; font-size: 1.1rem; cursor: pointer;}
.reviews-section .btn-primary:hover { filter: brightness(1.05); }
.reviews-section .btn-primary:active { transform: translateY(1px); }

.reviews-section .empty, .reviews-section .error { text-align: center; opacity: .9; }

/* Center empty/rate-limit message inside grid */
.reviews-section .empty-grid { grid-column: 1; justify-self: center; align-self: center; }
@media (min-width: 640px) { .reviews-section .empty-grid { grid-column: 1 / -1; } }
@media (min-width: 1024px) { .reviews-section .empty-grid { grid-column: 2; } }
.reviews-section .empty-grid .empty,
.reviews-section .empty-grid .error {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 240px;
}

/* a11y + Modals */
.reviews-section .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
.reviews-section .modal-mask[hidden] { display: none !important; }
.reviews-section .modal-mask { position: fixed; inset: 0; background: rgba(0,0,0,.55); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); }
.reviews-section .modal { width: min(720px, 92vw); background: var(--ctp-surface0); border: 1px solid var(--ctp-surface1); border-radius: 14px; box-shadow: 0 20px 60px rgba(0,0,0,.35); overflow: hidden; }
.reviews-section .modal-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 14px; background: var(--ctp-surface1); }
.reviews-section .modal-header h3 { margin: 0; font-size: 1.2rem; display: flex; gap: .5rem; align-items: center; }
.reviews-section .modal-header .icon { color: var(--ctp-mauve); }
.reviews-section .modal-close { background: transparent; border: none; color: var(--ctp-text); font-size: 1.2rem; cursor: pointer; opacity: .8; margin: 0;}
.reviews-section .modal-close:hover { opacity: 1; }
.reviews-section .modal-body { padding: 14px; display: flex; flex-direction: column; gap: 12px; }
.reviews-section .modal-body .modal-review-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 8px; }
.reviews-section .modal-body .view-author { display: flex; align-items: center; gap: 8px; }
.reviews-section .modal-body .view-author .avatar { width: 44px; height: 44px; border-radius: 50%; border: 2px solid var(--ctp-mauve, #cba6f7); object-fit: cover; }
.reviews-section .modal-body .view-rating { display: flex; align-items: center; gap: 8px; margin-top: 0; }
.reviews-section .modal-body .view-rating .stars { font-size: 22px; color: #f5b301; }
.reviews-section .modal-body .date { opacity: .8; }

/* Mobile adaptation for view modal */
@media (max-width: 640px) {
  .reviews-section .modal-body .modal-review-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }
  .reviews-section .modal-body .view-author {
    width: 100%;
    gap: 10px;
  }
  .reviews-section .modal-body .view-author .username {
    max-width: 100%;
    overflow-wrap: anywhere;
    word-break: break-word;
  }
  .reviews-section .modal-body .view-rating {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 8px;
    margin-top: 2px;
  }
  .reviews-section .modal-body .view-rating .stars { font-size: 20px; }
  .reviews-section .modal-body .date { font-size: 0.9rem; }
}

/* Leave-review form alignment */
.reviews-section .stars-select { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
.reviews-section .stars-row { display: flex; gap: 8px; align-items: center; margin: 0;}
.reviews-section .star-btn { display: inline-flex; align-items: center; justify-content: center; font-size: 28px; line-height: 1; background: transparent; border: none; cursor: pointer; color: var(--ctp-text); padding: 0; margin: 0;}
.reviews-section .star-btn[aria-pressed="true"] { color: #f5b301; }
.reviews-section .review-text { width: 100%; min-height: 120px; background: transparent; color: var(--ctp-text); border: 1px solid var(--ctp-surface1); border-radius: 10px; padding: 10px 12px; resize: vertical; }
.reviews-section .review-text:focus { outline: none; border-color: var(--ctp-mauve); box-shadow: 0 0 0 2px color-mix(in oklab, var(--ctp-mauve) 25%, transparent); }
.reviews-section .modal-actions { display: flex; justify-content: flex-end; }
.reviews-section .hint { text-align: center; opacity: .8; font-size: .9rem; }

</style>

